// services/OpenAIService.ts
import OpenAI from 'openai';
import { Logger } from '@/utils/Logger';
export class OpenAIService {
    constructor() {
        this.logger = new Logger('OpenAIService');
        this.client = new OpenAI({
            apiKey: process.env["OPENAI_API_KEY"],
        });
    }
    async generateContent(prompt, context) {
        try {
            const systemPrompt = `You are a professional business development specialist and content creator who helps organizations "change the world one solution at a time." Your writing style is:
      
      - Professional but approachable
      - Solution-focused and optimistic
      - Action-oriented with concrete insights
      - Engaging and conversational
      - Focused on problem-solving and innovation
      
      Always include actionable insights and maintain a tone that resonates with business leaders and entrepreneurs.`;
            const completion = await this.client.chat.completions.create({
                model: process.env["OPENAI_MODEL"] || 'gpt-4',
                messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: prompt }
                ],
                max_tokens: parseInt(process.env.OPENAI_MAX_TOKENS || '500'),
                temperature: parseFloat(process.env.OPENAI_TEMPERATURE || '0.7'),
            });
            const content = completion.choices[0]?.message?.content;
            if (!content) {
                throw new Error('No content generated by OpenAI');
            }
            this.logger.info('Content generated successfully');
            return content.trim();
        }
        catch (error) {
            this.logger.error('OpenAI content generation failed:', error);
            throw new Error(`Content generation failed: ${error.message}`);
        }
    }
    async enhanceContent(content, platform) {
        const platformSpecs = this.getPlatformSpecifications(platform);
        const prompt = `Enhance this social media content for ${platform}:

    Original content: "${content}"
    
    Platform requirements:
    - Character limit: ${platformSpecs.charLimit}
    - Tone: ${platformSpecs.tone}
    - Best practices: ${platformSpecs.bestPractices.join(', ')}
    
    Please:
    1. Optimize the content for ${platform} while maintaining the core message
    2. Ensure it's within the character limit
    3. Make it more engaging and platform-appropriate
    4. Add relevant hashtags if appropriate
    5. Maintain professional but approachable tone
    
    Return only the enhanced content:`;
        return await this.generateContent(prompt);
    }
    async analyzeTrends(trends) {
        const prompt = `Analyze these trending topics for business development and social media potential:

    Trends: ${trends.join(', ')}
    
    For each trend, provide:
    1. Relevance score (0-1) for business professionals
    2. Content opportunity assessment
    3. Suggested content angles
    4. Potential hashtags
    5. Target audience fit
    
    Focus on trends that offer value to entrepreneurs, business leaders, and innovation-focused professionals.
    
    Return as JSON array with this structure:
    [
      {
        "topic": "trend name",
        "relevanceScore": 0.8,
        "contentOpportunity": "description",
        "suggestedAngles": ["angle1", "angle2"],
        "hashtags": ["#tag1", "#tag2"],
        "audienceFit": "description"
      }
    ]`;
        try {
            const analysis = await this.generateContent(prompt);
            return JSON.parse(analysis);
        }
        catch (error) {
            this.logger.error('Trend analysis failed:', error);
            return trends.map(trend => ({
                topic: trend,
                relevanceScore: 0.5,
                contentOpportunity: 'General business discussion opportunity',
                suggestedAngles: ['Industry impact', 'Business implications'],
                hashtags: [`#${trend.replace(/\s+/g, '')}`],
                audienceFit: 'General business audience'
            }));
        }
    }
    async optimizeForPlatform(content, platform) {
        return await this.enhanceContent(content, platform);
    }
    getPlatformSpecifications(platform) {
        const specs = {
            twitter: {
                charLimit: 280,
                tone: 'Concise and engaging',
                bestPractices: [
                    'Use relevant hashtags (1-3)',
                    'Include call-to-action',
                    'Keep it conversational',
                    'Use threads for longer content'
                ]
            },
            linkedin: {
                charLimit: 3000,
                tone: 'Professional and insightful',
                bestPractices: [
                    'Start with a hook',
                    'Provide valuable insights',
                    'Include industry-specific terminology',
                    'End with a question to encourage engagement'
                ]
            },
            facebook: {
                charLimit: 63206,
                tone: 'Conversational and community-focused',
                bestPractices: [
                    'Tell stories',
                    'Encourage community discussion',
                    'Use relatable language',
                    'Include clear call-to-action'
                ]
            },
            instagram: {
                charLimit: 2200,
                tone: 'Visual-first and inspiring',
                bestPractices: [
                    'Write for visual content',
                    'Use relevant hashtags (5-10)',
                    'Include emojis appropriately',
                    'Create shareable moments'
                ]
            },
            tiktok: {
                charLimit: 2200,
                tone: 'Trendy and engaging',
                bestPractices: [
                    'Hook viewers immediately',
                    'Use trending sounds/hashtags',
                    'Keep it entertaining',
                    'Include clear value proposition'
                ]
            }
        };
        return specs[platform] || specs.twitter;
    }
}
import { OpenAIService } from './OpenAIService';
export class ContentOptimizer {
    constructor() {
        this.logger = new Logger('ContentOptimizer');
        this.aiService = new OpenAIService();
    }
    async optimizeForPlatform(content, platform) {
        try {
            // Get platform-specific optimizations
            const optimizedText = await this.aiService.optimizeForPlatform(content, platform);
            // Extract hashtags and mentions
            const hashtags = this.extractHashtags(optimizedText);
            const mentions = this.extractMentions(optimizedText);
            // Calculate metrics
            const characterCount = optimizedText.length;
            const readabilityScore = this.calculateReadabilityScore(optimizedText);
            const sentimentScore = await this.calculateSentimentScore(optimizedText);
            // Validate against platform constraints
            await this.validatePlatformConstraints(optimizedText, platform);
            const result = {
                text: optimizedText,
                hashtags,
                mentions,
                characterCount,
                readabilityScore,
                sentimentScore
            };
            this.logger.info(`Content optimized for ${platform}: ${characterCount} characters, ${hashtags.length} hashtags`);
            return result;
        }
        catch (error) {
            this.logger.error(`Content optimization failed for ${platform}:`, error);
            // Return basic optimization as fallback
            return {
                text: content,
                hashtags: this.extractHashtags(content),
                mentions: this.extractMentions(content),
                characterCount: content.length,
                readabilityScore: 0,
                sentimentScore: 0
            };
        }
    }
    extractHashtags(text) {
        const hashtagRegex = /#[\w]+/g;
        const matches = text.match(hashtagRegex);
        return matches ? matches.map(tag => tag.toLowerCase()) : [];
    }
    extractMentions(text) {
        const mentionRegex = /@[\w]+/g;
        const matches = text.match(mentionRegex);
        return matches ? matches.map(mention => mention.toLowerCase()) : [];
    }
    calculateReadabilityScore(text) {
        // Simplified Flesch Reading Ease calculation
        const sentences = text.split(/[.!?]+/).length - 1;
        const words = text.split(/\s+/).length;
        const syllables = this.countSyllables(text);
        if (sentences === 0 || words === 0)
            return 0;
        const avgSentenceLength = words / sentences;
        const avgSyllablesPerWord = syllables / words;
        const score = 206.835 - (1.015 * avgSentenceLength) - (84.6 * avgSyllablesPerWord);
        return Math.max(0, Math.min(100, score));
    }
    countSyllables(text) {
        const words = text.toLowerCase().split(/\s+/);
        let totalSyllables = 0;
        for (const word of words) {
            const cleanWord = word.replace(/[^a-z]/g, '');
            if (cleanWord.length === 0)
                continue;
            let syllables = cleanWord.match(/[aeiouy]+/g)?.length || 0;
            // Adjust for silent e
            if (cleanWord.endsWith('e')) {
                syllables--;
            }
            // Ensure at least 1 syllable per word
            syllables = Math.max(1, syllables);
            totalSyllables += syllables;
        }
        return totalSyllables;
    }
    async calculateSentimentScore(text) {
        try {
            // Use AI to analyze sentiment
            const prompt = `Analyze the sentiment of this text and return a score from -1 (very negative) to 1 (very positive):

      Text: "${text}"
      
      Return only a number between -1 and 1 representing the sentiment score:`;
            const result = await this.aiService.generateContent(prompt);
            const score = parseFloat(result.trim());
            return isNaN(score) ? 0 : Math.max(-1, Math.min(1, score));
        }
        catch (error) {
            this.logger.error('Sentiment analysis failed:', error);
            return 0;
        }
    }
    async validatePlatformConstraints(text, platform) {
        const constraints = {
            twitter: { maxChars: 280, maxHashtags: 5 },
            linkedin: { maxChars: 3000, maxHashtags: 10 },
            facebook: { maxChars: 63206, maxHashtags: 15 },
            instagram: { maxChars: 2200, maxHashtags: 30 },
            tiktok: { maxChars: 2200, maxHashtags: 10 }
        };
        const constraint = constraints[platform];
        if (!constraint)
            return;
        if (text.length > constraint.maxChars) {
            throw new Error(`Content exceeds ${platform} character limit (${text.length}/${constraint.maxChars})`);
        }
        const hashtags = this.extractHashtags(text);
        if (hashtags.length > constraint.maxHashtags) {
            throw new Error(`Too many hashtags for ${platform} (${hashtags.length}/${constraint.maxHashtags})`);
        }
    }
    async generateHashtagSuggestions(content, platform, count = 5) {
        try {
            const prompt = `Generate ${count} relevant hashtags for this ${platform} post:

      Content: "${content}"
      
      Requirements:
      - Hashtags should be relevant to business development, innovation, and professional growth
      - Mix of popular and niche hashtags
      - Appropriate for the platform and content
      - No spaces in hashtags
      
      Return only the hashtags, one per line, including the # symbol:`;
            const result = await this.aiService.generateContent(prompt);
            const hashtags = result
                .split('\n')
                .map(line => line.trim())
                .filter(line => line.startsWith('#'))
                .slice(0, count);
            return hashtags;
        }
        catch (error) {
            this.logger.error('Hashtag generation failed:', error);
            return [];
        }
    }
    async optimizePostingTime(content, platform, timezone = 'America/New_York') {
        // Platform-specific optimal posting times (in hours)
        const optimalTimes = {
            twitter: [9, 12, 15, 17], // 9 AM, 12 PM, 3 PM, 5 PM
            linkedin: [8, 10, 12, 14, 17], // 8 AM, 10 AM, 12 PM, 2 PM, 5 PM
            facebook: [9, 13, 15], // 9 AM, 1 PM, 3 PM
            instagram: [11, 13, 17, 19], // 11 AM, 1 PM, 5 PM, 7 PM
            tiktok: [15, 18, 21] // 3 PM, 6 PM, 9 PM
        };
        const times = optimalTimes[platform] || optimalTimes.twitter;
        const now = new Date();
        const suggestions = [];
        // Generate next 7 days of optimal posting times
        for (let day = 0; day < 7; day++) {
            for (const hour of times) {
                const postTime = new Date(now);
                postTime.setDate(now.getDate() + day);
                postTime.setHours(hour, 0, 0, 0);
                // Only suggest future times
                if (postTime > now) {
                    suggestions.push(postTime);
                }
            }
        }
        return suggestions.slice(0, 10); // Return top 10 suggestions
    }
}
export class TrendAnalyzer {
    constructor() {
        this.logger = new Logger('TrendAnalyzer');
        this.aiService = new OpenAIService();
    }
    async getTrendingTopics(keywords, industries = []) {
        try {
            const trends = [];
            // Get Google Trends data
            const googleTrends = await this.getGoogleTrends(keywords);
            trends.push(...googleTrends);
            // Get Twitter trends (if configured)
            if (process.env.TWITTER_API_KEY) {
                const twitterTrends = await this.getTwitterTrends();
                trends.push(...twitterTrends);
            }
            // Get industry-specific trends
            for (const industry of industries) {
                const industryTrends = await this.getIndustryTrends(industry);
                trends.push(...industryTrends);
            }
            // Analyze and score trends
            const analyzedTrends = await this.analyzeTrendRelevance(trends, keywords.join(' '));
            // Sort by relevance and return top trends
            return analyzedTrends
                .sort((a, b) => b.relevanceScore - a.relevanceScore)
                .slice(0, 20);
        }
        catch (error) {
            this.logger.error('Failed to get trending topics:', error);
            return [];
        }
    }
    async getGoogleTrends(keywords) {
        // Note: This would typically use an unofficial Google Trends API
        // For production, consider using a service like SerpAPI or DataForSEO
        const trends = [];
        try {
            // Simulate Google Trends data for demo purposes
            // In production, integrate with actual Google Trends API or service
            for (const keyword of keywords) {
                trends.push({
                    id: crypto.randomUUID(),
                    topic: keyword,
                    platform: 'twitter', // Default platform
                    volume: Math.floor(Math.random() * 10000) + 1000,
                    sentimentScore: (Math.random() - 0.5) * 2, // -1 to 1
                    relevanceScore: Math.random(), // Will be recalculated
                    keywords: [keyword],
                    discoveredAt: new Date(),
                    sourceUrls: [`https://trends.google.com/trends/explore?q=${encodeURIComponent(keyword)}`]
                });
            }
            this.logger.info(`Generated ${trends.length} trends from Google Trends`);
            return trends;
        }
        catch (error) {
            this.logger.error('Google Trends API error:', error);
            return [];
        }
    }
    async getTwitterTrends() {
        // This would use the Twitter API to get trending topics
        // Implementation depends on Twitter API v2 access
        const trends = [];
        try {
            // Placeholder for Twitter Trends API integration
            // In production, implement actual Twitter API calls
            this.logger.info('Twitter trends not implemented yet');
            return trends;
        }
        catch (error) {
            this.logger.error('Twitter Trends API error:', error);
            return [];
        }
    }
    async getIndustryTrends(industry) {
        try {
            // Use AI to generate industry-specific trending topics
            const prompt = `Generate 5 current trending topics in the ${industry} industry that would be relevant for business professionals and social media content.

      For each topic, provide:
      - The trend name/topic
      - Key related keywords (2-3)
      - Estimated discussion volume (low/medium/high)
      
      Focus on topics that are:
      - Currently discussed in business circles
      - Relevant for professional development
      - Suitable for social media engagement
      
      Return as JSON array:
      [
        {
          "topic": "trend name",
          "keywords": ["keyword1", "keyword2"],
          "volume": "medium"
        }
      ]`;
            const result = await this.aiService.generateContent(prompt);
            const industryData = JSON.parse(result);
            const trends = industryData.map((item) => ({
                id: crypto.randomUUID(),
                topic: item.topic,
                platform: 'twitter',
                volume: this.volumeToNumber(item.volume),
                sentimentScore: 0.1, // Slightly positive for business topics
                relevanceScore: 0.8, // High relevance for industry-specific trends
                keywords: item.keywords,
                discoveredAt: new Date(),
                sourceUrls: []
            }));
            return trends;
        }
        catch (error) {
            this.logger.error(`Failed to get ${industry} trends:`, error);
            return [];
        }
    }
    volumeToNumber(volume) {
        switch (volume.toLowerCase()) {
            case 'high': return Math.floor(Math.random() * 5000) + 5000;
            case 'medium': return Math.floor(Math.random() * 3000) + 1000;
            case 'low': return Math.floor(Math.random() * 1000) + 100;
            default: return Math.floor(Math.random() * 1000) + 500;
        }
    }
    async analyzeTrendRelevance(trends, context) {
        try {
            const batchSize = 10;
            const analyzedTrends = [];
            // Process trends in batches to avoid token limits
            for (let i = 0; i < trends.length; i += batchSize) {
                const batch = trends.slice(i, i + batchSize);
                const trendTopics = batch.map(t => t.topic).join(', ');
                const prompt = `Analyze these trending topics for relevance to business development and professional content creation:

        Context: ${context}
        Trends: ${trendTopics}
        
        For each trend, assess:
        1. Relevance for business professionals (0-1 score)
        2. Content creation potential (0-1 score)
        3. Audience engagement potential (0-1 score)
        
        Return JSON array with relevance scores:
        [
          {
            "topic": "trend name",
            "relevanceScore": 0.8,
            "contentPotential": 0.9,
            "engagementPotential": 0.7,
            "reasoning": "brief explanation"
          }
        ]`;
                try {
                    const analysisResult = await this.aiService.generateContent(prompt);
                    const analysis = JSON.parse(analysisResult);
                    // Update trends with AI analysis
                    batch.forEach((trend, index) => {
                        if (analysis[index]) {
                            const scores = analysis[index];
                            trend.relevanceScore = scores.relevanceScore || 0.5;
                            // Add AI insights as metadata
                            trend.contentPotential = scores.contentPotential;
                            trend.engagementPotential = scores.engagementPotential;
                            trend.reasoning = scores.reasoning;
                        }
                        analyzedTrends.push(trend);
                    });
                }
                catch (error) {
                    this.logger.error('Batch analysis failed, using default scores:', error);
                    // Use original trends with default relevance
                    analyzedTrends.push(...batch);
                }
            }
            this.logger.info(`Analyzed ${analyzedTrends.length} trends for relevance`);
            return analyzedTrends;
        }
        catch (error) {
            this.logger.error('Trend relevance analysis failed:', error);
            return trends; // Return original trends if analysis fails
        }
    }
    async getRelatedKeywords(topic) {
        try {
            const prompt = `Generate 8-10 related keywords and phrases for the topic: "${topic}"

      Focus on:
      - Business and professional terminology
      - Industry-specific terms
      - Hashtag-friendly keywords
      - Synonyms and variations
      
      Return as a simple list, one per line:`;
            const result = await this.aiService.generateContent(prompt);
            const keywords = result
                .split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0 && !line.startsWith('-'))
                .slice(0, 10);
            return keywords;
        }
        catch (error) {
            this.logger.error('Related keywords generation failed:', error);
            return [topic];
        }
    }
}
import { SocialMediaFactory } from './SocialMediaFactory';
export class AnalyticsCollector {
    constructor() {
        this.logger = new Logger('AnalyticsCollector');
        this.aiService = new OpenAIService();
    }
    async collectPlatformMetrics(platform) {
        try {
            const service = SocialMediaFactory.create(platform);
            await service.authenticate();
            const metrics = await service.getMetrics();
            this.logger.info(`Collected metrics for ${platform}`);
            return metrics;
        }
        catch (error) {
            this.logger.error(`Failed to collect metrics for ${platform}:`, error);
            return null;
        }
    }
    async analyzeCompetitor(competitorName, platform, handle) {
        try {
            // This would typically involve:
            // 1. Scraping competitor's recent posts
            // 2. Analyzing engagement metrics
            // 3. Identifying content patterns
            // 4. Generating insights
            // For demo purposes, generating simulated analysis
            const analysis = {
                id: crypto.randomUUID(),
                competitorName,
                platform,
                handle,
                content: `Recent ${platform} content analysis`,
                engagementRate: Math.random() * 10, // 0-10%
                postTime: new Date(),
                hashtags: ['#business', '#innovation', '#growth'],
                contentType: 'text',
                metrics: {
                    likes: Math.floor(Math.random() * 1000),
                    comments: Math.floor(Math.random() * 100),
                    shares: Math.floor(Math.random() * 50),
                    views: Math.floor(Math.random() * 5000)
                },
                insights: await this.generateCompetitorInsights(competitorName, platform),
                analyzedAt: new Date()
            };
            return analysis;
        }
        catch (error) {
            this.logger.error(`Failed to analyze competitor ${competitorName} on ${platform}:`, error);
            throw error;
        }
    }
    async generateCompetitorInsights(competitorName, platform) {
        try {
            const prompt = `Generate competitive intelligence insights for ${competitorName} on ${platform}.

      Provide actionable insights about:
      1. Content strategy patterns
      2. Engagement tactics
      3. Posting frequency and timing
      4. Audience interaction approach
      5. Opportunities for differentiation
      
      Keep insights professional and strategic, focusing on learnings that can improve our own social media approach.
      
      Insights:`;
            return await this.aiService.generateContent(prompt);
        }
        catch (error) {
            this.logger.error('Failed to generate competitor insights:', error);
            return 'Competitive analysis insights unavailable';
        }
    }
    async calculateGrowthRate(currentMetrics, previousMetrics) {
        if (previousMetrics.followersCount === 0)
            return 0;
        const growthRate = ((currentMetrics.followersCount - previousMetrics.followersCount) /
            previousMetrics.followersCount) * 100;
        return Math.round(growthRate * 100) / 100; // Round to 2 decimal places
    }
    async generateAnalyticsReport(metrics) {
        try {
            const reportData = metrics.map(metric => ({
                platform: metric.platform,
                followers: metric.followersCount,
                engagement: metric.engagementRate,
                growth: metric.growthRate
            }));
            const prompt = `Generate a comprehensive social media analytics report based on this data:

      ${JSON.stringify(reportData, null, 2)}

      The report should include:
      1. Executive summary of performance
      2. Platform-by-platform analysis
      3. Key insights and trends
      4. Actionable recommendations
      5. Areas for improvement
      
      Write in a professional tone suitable for business stakeholders.
      
      Report:`;
            return await this.aiService.generateContent(prompt);
        }
        catch (error) {
            this.logger.error('Failed to generate analytics report:', error);
            return 'Analytics report generation failed';
        }
    }
}
//# sourceMappingURL=ai-content-services.js.map